# ============================================
# PRODUCTION NGINX CONFIGURATION
# ============================================
# This config assumes Nginx runs inside Docker and is accessed
# through a reverse proxy (host Nginx) that handles SSL termination.
#
# Request flow:
# User → Host Nginx (SSL, port 443) → Docker Nginx (port 80) → PHP-FPM
# ============================================

server {
    # Listen on port 80 (HTTP only)
    # SSL is handled by the host's reverse proxy, not this container
    listen 80;

    # server_name "_" is a catch-all that matches any hostname
    # The actual domain is handled by the host's reverse proxy
    # In dev you might use "localhost", but "_" works everywhere
    server_name _;

    # Document root - Laravel's public directory
    # All web requests start here. Laravel's index.php handles routing.
    root /var/www/html/public;

    # Default file to serve when requesting a directory
    index index.php;

    # ============================================
    # SERVER IDENTIFICATION
    # ============================================
    # By default, Nginx sends "Server: nginx/1.24.0" header
    # This exposes your server software and version to attackers
    # They can look up known vulnerabilities for that version
    #
    # server_tokens off; removes the version number
    # Response will just show "Server: nginx" (can't fully hide it without recompiling)
    server_tokens off;

    # ============================================
    # UPLOAD SIZE LIMIT
    # ============================================
    # Maximum allowed size of the client request body
    # If someone uploads a file larger than this, they get 413 error
    #
    # This should match your PHP settings:
    # - upload_max_filesize = 100M
    # - post_max_size = 100M (should be >= upload_max_filesize)
    #
    # Set based on your app's needs (profile photos? documents? videos?)
    client_max_body_size 100M;

    # ============================================
    # SECURITY HEADERS
    # ============================================
    # These headers instruct browsers to enable security features
    # "always" means add header even on error responses (404, 500, etc.)

    # X-Frame-Options: Prevents your site from being embedded in <iframe>
    # This stops "clickjacking" attacks where attackers overlay invisible
    # frames to trick users into clicking things
    #
    # Values:
    # - DENY: Never allow framing (strictest)
    # - SAMEORIGIN: Only allow framing from same domain (allows your own modals)
    # - ALLOW-FROM uri: Allow specific domain (deprecated, use CSP instead)
    add_header X-Frame-Options "SAMEORIGIN" always;

    # X-Content-Type-Options: Prevents MIME type sniffing
    # Without this, browsers might "guess" that a .txt file is actually HTML
    # and execute scripts inside it. This forces browser to trust the
    # Content-Type header we send.
    #
    # Only valid value is "nosniff"
    add_header X-Content-Type-Options "nosniff" always;

    # X-XSS-Protection: Enables browser's built-in XSS filter
    # This is DEPRECATED in modern browsers (Chrome removed it in 2019)
    # but still helps protect users on older browsers (IE, old Safari)
    #
    # Values:
    # - 0: Disable filter
    # - 1: Enable filter (sanitize page)
    # - 1; mode=block: Enable filter, block entire page if attack detected
    add_header X-XSS-Protection "1; mode=block" always;

    # Referrer-Policy: Controls how much referrer info is sent when
    # users click links to other sites
    #
    # When user goes from yoursite.com/secret-page to external.com,
    # should external.com know they came from /secret-page?
    #
    # Values:
    # - no-referrer: Never send referrer (most private, breaks some analytics)
    # - same-origin: Only send referrer for same-site links
    # - strict-origin-when-cross-origin: Send full URL for same-origin,
    #   only origin (domain) for cross-origin HTTPS, nothing for HTTP downgrade
    #   (Good balance of privacy and functionality)
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Permissions-Policy (formerly Feature-Policy)
    # Controls which browser features your site can use
    # This prevents malicious scripts from accessing sensitive APIs
    #
    # Format: feature=(allowlist)
    # - () means disabled entirely
    # - (self) means only your origin
    # - * means any origin (dangerous)
    #
    # Common features to restrict:
    # - camera, microphone: Prevent unauthorized recording
    # - geolocation: Prevent location tracking
    # - payment: Prevent unauthorized payment requests
    #
    # Add features your app actually needs, like:
    # camera=(self) if you have video chat
    add_header Permissions-Policy "camera=(), microphone=(), geolocation=()" always;

    # ============================================
    # REAL IP HANDLING (Behind Reverse Proxy)
    # ============================================
    # Problem: When behind a reverse proxy, all requests appear to come
    # from the proxy's IP (127.0.0.1 or Docker network IP), not the real user.
    #
    # Your logs would show:
    #   127.0.0.1 - GET /login  (useless - that's the proxy, not the user)
    #
    # Solution: The reverse proxy adds X-Forwarded-For header with real IP.
    # We tell Nginx to trust this header from specific sources.
    #
    # SECURITY: Only trust X-Forwarded-For from known proxies!
    # If you trust everyone, attackers can spoof their IP by sending
    # fake X-Forwarded-For headers.

    # set_real_ip_from: IP ranges we trust to send real IP
    # These are private/internal networks where your proxy lives
    set_real_ip_from 172.16.0.0/12;  # Docker default bridge networks (172.17.x.x, etc.)
    set_real_ip_from 10.0.0.0/8;     # Private network range (common in cloud/VPCs)
    set_real_ip_from 127.0.0.1;      # Localhost (if proxy is on same machine)

    # real_ip_header: Which header contains the real IP
    # X-Forwarded-For is standard, but some proxies use X-Real-IP
    real_ip_header X-Forwarded-For;

    # real_ip_recursive: How to handle chained proxies
    # X-Forwarded-For can contain multiple IPs: "client, proxy1, proxy2"
    #
    # With recursive ON: Nginx walks backwards through the list,
    # skipping trusted proxy IPs, until it finds an untrusted one (the client)
    #
    # Example: X-Forwarded-For: 1.2.3.4, 10.0.0.5, 172.17.0.1
    # - 172.17.0.1 is trusted (Docker) - skip
    # - 10.0.0.5 is trusted (private) - skip
    # - 1.2.3.4 is NOT trusted - this is the real client IP
    real_ip_recursive on;

    # ============================================
    # MAIN LOCATION (Laravel Front Controller)
    # ============================================
    # All requests that don't match other location blocks come here

    location / {
        # try_files: Try to serve the request in order:
        # 1. $uri - Try to serve as a real file (e.g., /image.jpg)
        # 2. $uri/ - Try to serve as a directory (looks for index file)
        # 3. /index.php?$query_string - Pass to Laravel's front controller
        #
        # This is the Laravel routing pattern - all non-file requests
        # go through index.php, which loads the framework and routes
        try_files $uri $uri/ /index.php?$query_string;
    }

    # ============================================
    # PHP HANDLING (FastCGI to PHP-FPM)
    # ============================================
    # Files ending in .php are passed to PHP-FPM for processing
    #
    # How FastCGI works:
    # 1. Nginx receives request for .php file
    # 2. Nginx connects to PHP-FPM (separate process) via socket or TCP
    # 3. Nginx sends request details (path, headers, body)
    # 4. PHP-FPM executes the script and returns output
    # 5. Nginx sends PHP's output to the client

    location ~ \.php$ {
        # Where to send PHP requests
        # "php" is the Docker service name, resolved via Docker's DNS
        # 9000 is PHP-FPM's default port
        #
        # Alternative for same-server: unix:/var/run/php/php-fpm.sock
        fastcgi_pass php:9000;

        # Default file when requesting a directory with trailing slash
        fastcgi_index index.php;

        # SCRIPT_FILENAME: The actual file path PHP should execute
        # $realpath_root resolves symlinks to get the real path
        # $fastcgi_script_name is the URI path (e.g., /index.php)
        #
        # Result: /var/www/html/public/index.php
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;

        # Include standard FastCGI parameters
        # This file defines: QUERY_STRING, REQUEST_METHOD, CONTENT_TYPE,
        # REMOTE_ADDR, SERVER_NAME, and many more that PHP needs
        include fastcgi_params;

        # ----------------------------------------
        # BUFFER SETTINGS
        # ----------------------------------------
        # PHP-FPM sends response in chunks. Nginx buffers these before
        # sending to client. If buffers are too small, Nginx writes
        # to temp files (slow).
        #
        # fastcgi_buffers: Number and size of buffers for response body
        # 16 buffers × 16KB = 256KB buffered in memory
        fastcgi_buffers 16 16k;

        # fastcgi_buffer_size: Buffer for first part of response (headers)
        # Headers are usually small, but 32k handles large cookies/headers
        fastcgi_buffer_size 32k;

        # ----------------------------------------
        # TIMEOUT SETTINGS
        # ----------------------------------------
        # How long to wait for PHP-FPM at each stage
        # Increase these if you have legitimate long-running requests
        # (imports, reports, etc.), but not too high or slow scripts
        # tie up connections

        # Time to wait for connection to PHP-FPM
        fastcgi_connect_timeout 60s;

        # Time to wait when sending request to PHP-FPM
        fastcgi_send_timeout 60s;

        # Time to wait for PHP-FPM to send response
        # This is usually the one to increase for slow scripts
        fastcgi_read_timeout 60s;

        # ----------------------------------------
        # HIDE PHP VERSION
        # ----------------------------------------
        # By default, PHP sends "X-Powered-By: PHP/8.4.0" header
        # Like server_tokens, this reveals software versions to attackers
        #
        # Best practice: Also set expose_php=Off in php.ini
        # This removes it at the source, but this is a backup
        fastcgi_hide_header X-Powered-By;
    }

    # ============================================
    # STATIC ASSET CACHING
    # ============================================
    # We have TWO types of static file handling:
    #
    # 1. VITE BUILD ASSETS (/build/*) - Aggressive caching
    #    These have hashed filenames, so we cache forever
    #
    # 2. OTHER STATIC FILES - Try file, fall back to Laravel
    #    URLs like /images/12/test.jpg might be Laravel routes!
    #    Only serve as static if file actually exists

    # ----------------------------------------
    # VITE/MIX BUILD ASSETS
    # ----------------------------------------
    # Files in /build/ are generated by Vite with content hashes
    # e.g., /build/assets/app-DfG7h2Kj.js
    #
    # These NEVER change at the same URL (hash changes = new URL)
    # So we cache aggressively: 1 year, immutable
    location /build/ {
        expires 1y;
        add_header Cache-Control "public, immutable";
        access_log off;
        add_header X-Content-Type-Options "nosniff" always;
    }

    # ----------------------------------------
    # FAVICON & ROBOTS (root static files)
    # ----------------------------------------
    # These are always real files in public/
    location = /favicon.ico {
        expires 1M;
        access_log off;
        add_header Cache-Control "public";
    }

    location = /robots.txt {
        expires 1d;
        access_log off;
        add_header Cache-Control "public";
    }

    # ----------------------------------------
    # OTHER STATIC FILES
    # ----------------------------------------
    # For URLs like /images/photo.jpg or /storage/uploads/file.pdf
    #
    # IMPORTANT: We use try_files to check if file exists
    # If file exists → serve it with caching headers
    # If file doesn't exist → pass to Laravel (might be a route!)
    #
    # This allows:
    # - /storage/image.jpg → served as static file (if exists)
    # - /images/12/test.jpg → passed to Laravel controller (no file)
    #
    # ~* means case-insensitive regex
    location ~* \.(css|js|jpg|jpeg|png|gif|ico|svg|woff|woff2|ttf|eot|webp|avif|pdf|mp4|webm|mp3|zip)$ {
        # Try to serve as static file, fall back to Laravel
        # $uri = try exact path
        # /index.php?$query_string = pass to Laravel if not found
        try_files $uri /index.php?$query_string;

        # Moderate caching (not immutable - files might change)
        expires 1M;
        add_header Cache-Control "public";
        access_log off;
        add_header X-Content-Type-Options "nosniff" always;
    }

    # ============================================
    # BLOCK SENSITIVE FILES
    # ============================================
    # These patterns prevent access to files that should never be public
    # Even if someone accidentally puts them in /public, they're blocked

    # ----------------------------------------
    # HIDDEN FILES (dotfiles)
    # ----------------------------------------
    # Block all files/directories starting with dot
    # This catches: .env, .git/, .htaccess, .gitignore, etc.
    #
    # ~ means regex match (case sensitive)
    # /\. matches any path containing /. (slash followed by dot)
    location ~ /\. {
        deny all;      # Return 403 Forbidden
        return 404;    # Actually return 404 to not confirm file exists
    }

    # ----------------------------------------
    # COMPOSER FILES
    # ----------------------------------------
    # composer.json reveals your dependencies and versions
    # composer.lock is even worse - exact versions of everything
    # Attackers can look for known vulnerabilities in your dependencies
    location ~ composer\.(json|lock)$ {
        deny all;
        return 404;
    }

    # ----------------------------------------
    # NPM/NODE FILES
    # ----------------------------------------
    # Same reason as Composer - reveals dependencies
    # package.json shows what JS packages you use
    # package-lock.json shows exact versions
    location ~ package(-lock)?\.json$ {
        deny all;
        return 404;
    }

    # ----------------------------------------
    # CONFIG/SENSITIVE FILE TYPES
    # ----------------------------------------
    # Block file types that should never be served directly:
    #
    # .yml/.yaml - Config files (docker-compose, CI configs)
    # .xml - Config files, also can be used for XXE attacks
    # .ini - PHP/app config files
    # .log - Log files may contain sensitive errors, IPs, emails
    # .sh - Shell scripts
    # .sql - Database dumps (!)
    # .bak - Backup files (often copies of .env, config, etc.)
    # .swp - Vim swap files (may contain file contents)
    location ~ \.(yml|yaml|xml|ini|log|sh|sql|bak|swp)$ {
        deny all;
        return 404;
    }

    # ----------------------------------------
    # LARAVEL STORAGE DIRECTORY
    # ----------------------------------------
    # Laravel's storage directory should not be web accessible
    # even though storage/app/public IS (via symlink to public/storage)
    #
    # This blocks direct access to:
    # - storage/app - User uploads before they're made public
    # - storage/framework - Sessions, cache, views (sensitive!)
    # - storage/logs - Error logs with stack traces, user data
    #
    # ^/storage/ means: starts with /storage/
    #
    # Note: public/storage symlink still works because that's a
    # different path (not blocked by this rule)
    location ~ ^/storage/(app|framework|logs) {
        deny all;
        return 404;
    }

    # ============================================
    # GZIP COMPRESSION
    # ============================================
    # Compresses responses before sending to client
    # Reduces bandwidth usage and speeds up page loads
    #
    # Trade-off: Uses CPU to compress, but usually worth it
    # Modern CPUs compress faster than networks transfer

    # Enable gzip compression
    gzip on;

    # Add "Vary: Accept-Encoding" header
    # Tells caches (CDN, browser) that response varies based on whether
    # client supports gzip. Without this, a CDN might serve gzipped
    # content to a client that can't decompress it.
    gzip_vary on;

    # Minimum response size to compress (in bytes)
    # Very small responses don't benefit from compression
    # and the gzip overhead might make them larger
    # 1024 bytes = 1KB is a good threshold
    gzip_min_length 1024;

    # Compression level (1-9)
    # 1 = fastest, least compression
    # 9 = slowest, most compression
    # 5-6 is sweet spot: good compression without too much CPU
    gzip_comp_level 5;

    # Compress responses to proxied requests too
    # "any" means always compress if client accepts gzip
    # Even if the request came through a proxy
    gzip_proxied any;

    # MIME types to compress
    # Only compress text-based formats - images/videos are already compressed
    #
    # Note: text/html is always compressed (hardcoded in nginx)
    # so we don't list it here
    gzip_types
        text/plain              # .txt files
        text/css                # Stylesheets
        text/xml                # XML documents
        text/javascript         # Old JS MIME type
        application/javascript  # Modern JS MIME type
        application/json        # JSON API responses
        application/xml         # XML API responses
        application/rss+xml     # RSS feeds
        application/atom+xml    # Atom feeds
        image/svg+xml;          # SVG images (XML-based, compresses well)
}
